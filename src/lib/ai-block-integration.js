/**
 * Example integration of AI Block Generator with Scratch Editor
 * This demonstrates how to use the handleAISuggestion function in a real Scratch-like editor
 */

import { handleAISuggestion, createBlockJSON } from './ai-block-generator';

/**
 * Enhanced version of addBlockToPalette that integrates with the Scratch-blocks system
 * This should be called from within the Blocks container component
 */
export function integrateAIBlockGenerator(blocksInstance) {
    const isKnownBlockType = (type) => {
        try {
            const SB = blocksInstance.ScratchBlocks || (typeof window !== 'undefined' ? window.ScratchBlocks : null);
            return !!(SB && SB.Blocks && SB.Blocks[type]);
        } catch {
            return false;
        }
    };

    // Map fuzzy AI output to real Scratch opcodes with defaults
    const normalizeToKnownBlock = (block) => {
        if (!block || !block.id) return null;
        // If already a known type, keep as-is
        if (isKnownBlockType(block.id)) return block;

        const text = `${block.label || ''} ${block.id || ''}`.toLowerCase();
        const out = { ...block };

        const set = (id, category, defaults) => ({
            ...out,
            id,
            category: category || out.category,
            defaultValues: { ...(out.defaultValues || {}), ...(defaults || {}) }
        });

        if (/\bmove\b/.test(text)) return set('motion_movesteps', 'motion', { STEPS: out.defaultValues?.STEPS || '10' });
        if (/\bturn\b.*(right|clockwise)/.test(text)) return set('motion_turnright', 'motion', { DEGREES: out.defaultValues?.DEGREES || '15' });
        if (/\bturn\b.*(left|anticlockwise)/.test(text)) return set('motion_turnleft', 'motion', { DEGREES: out.defaultValues?.DEGREES || '15' });
        if (/\bwait\b/.test(text)) return set('control_wait', 'control', { DURATION: out.defaultValues?.DURATION || out.defaultValues?.SECS || '1' });
        if (/\brepeat\b/.test(text)) return set('control_repeat', 'control', { TIMES: out.defaultValues?.TIMES || '10' });
        if (/\bforever\b/.test(text)) return set('control_forever', 'control');
        if (/(say|message)/.test(text)) return set('looks_say', 'looks', { MESSAGE: out.defaultValues?.MESSAGE || 'Hello!' });
        if (/think/.test(text)) return set('looks_think', 'looks', { MESSAGE: out.defaultValues?.MESSAGE || 'Hmmm...' });

        // Unknown -> skip
        return null;
    };
    /**
     * Add a dynamically generated block to the palette
     * @param {Object} block - Block object generated by handleAISuggestion
     */
    function addBlockToPalette(block) {
        try {
            // Normalize to known block or skip
            const normalized = normalizeToKnownBlock(block);
            if (!normalized) {
                console.warn('Skipping unknown AI block type:', block);
                return false;
            }
            const safeBlock = normalized;
            if (!isKnownBlockType(safeBlock.id)) {
                console.warn('Block type not registered in ScratchBlocks, skipping:', safeBlock.id);
                return false;
            }
            
            // Get current toolbox XML
            const currentToolbox = blocksInstance.getToolboxXML();
            
            // Insert the new block into the appropriate category in the toolbox
            const updatedToolbox = addBlockToToolboxXML(currentToolbox, safeBlock);
            
            // Update the toolbox
            if (updatedToolbox && blocksInstance.props.updateToolboxState) {
                blocksInstance.props.updateToolboxState(updatedToolbox);
            }
            
            console.log('AI block added successfully:', safeBlock.label || safeBlock.id);
            return true;
            
        } catch (error) {
            console.error('Error adding AI block to palette:', error);
            return false;
        }
    }
    
    /**
     * Insert a block XML into the toolbox at the appropriate category
     */
    function addBlockToToolboxXML(toolboxXML, block) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(toolboxXML, 'text/xml');
            
            // Find the appropriate category
            const categories = xmlDoc.querySelectorAll('category');
            let targetCategory = null;
            
            for (const category of categories) {
                if (category.getAttribute('id') === block.category) {
                    targetCategory = category;
                    break;
                }
            }
            
            // If category not found, add to 'More Blocks' or create AI category
            if (!targetCategory) {
                targetCategory = findOrCreateAICategory(xmlDoc);
            }
            
            if (targetCategory) {
                // Create block XML element
                const blockElement = xmlDoc.createElement('block');
                blockElement.setAttribute('type', block.id);
                
                // Add inputs as shadow blocks with default values
                if (block.inputs && block.inputs.length > 0) {
                    block.inputs.forEach((input, index) => {
                        if (input.type === 'input_value') {
                            const valueElement = xmlDoc.createElement('value');
                            valueElement.setAttribute('name', input.name);
                            
                            // Add appropriate shadow block based on input type and default values
                            const shadowElement = xmlDoc.createElement('shadow');
                            const defaultValue = block.defaultValues?.[input.name];
                            
                            if (input.check === 'Boolean') {
                                shadowElement.setAttribute('type', 'logic_boolean');
                                const fieldElement = xmlDoc.createElement('field');
                                fieldElement.setAttribute('name', 'BOOL');
                                fieldElement.textContent = defaultValue || 'TRUE';
                                shadowElement.appendChild(fieldElement);
                            } else if (input.name.includes('NUMBER') || input.name.includes('NUM') || 
                                      input.name.includes('TIMES') || input.name.includes('STEPS') ||
                                      input.name.includes('DEGREES') || input.name.includes('DURATION') ||
                                      input.name.includes('FROM') || input.name.includes('TO') ||
                                      input.name.includes('SECS')) {
                                shadowElement.setAttribute('type', 'math_number');
                                const fieldElement = xmlDoc.createElement('field');
                                fieldElement.setAttribute('name', 'NUM');
                                fieldElement.textContent = defaultValue || '0';
                                shadowElement.appendChild(fieldElement);
                            } else {
                                shadowElement.setAttribute('type', 'text');
                                const fieldElement = xmlDoc.createElement('field');
                                fieldElement.setAttribute('name', 'TEXT');
                                fieldElement.textContent = defaultValue || '';
                                shadowElement.appendChild(fieldElement);
                            }
                            
                            valueElement.appendChild(shadowElement);
                            blockElement.appendChild(valueElement);
                        }
                    });
                }
                
                // Add separator before our block
                const separator = xmlDoc.createElement('sep');
                separator.setAttribute('gap', '36');
                targetCategory.appendChild(separator);
                
                // Add the block
                targetCategory.appendChild(blockElement);
                
                // Serialize back to string
                const serializer = new XMLSerializer();
                return serializer.serializeToString(xmlDoc);
            }
            
        } catch (error) {
            console.error('Error updating toolbox XML:', error);
        }
        
        return toolboxXML; // Return original if update failed
    }
    
    /**
     * Find or create an AI category in the toolbox
     */
    function findOrCreateAICategory(xmlDoc) {
        // First, try to find existing AI category
        const categories = xmlDoc.querySelectorAll('category');
        for (const category of categories) {
            if (category.getAttribute('name') === 'AI Blocks' || category.getAttribute('id') === 'ai') {
                return category;
            }
        }
        
        // Create new AI category
        const toolbox = xmlDoc.querySelector('xml');
        if (toolbox) {
            const aiCategory = xmlDoc.createElement('category');
            aiCategory.setAttribute('name', 'AI Blocks');
            aiCategory.setAttribute('id', 'ai');
            aiCategory.setAttribute('colour', '#FF6B6B');
            aiCategory.setAttribute('secondaryColour', '#FF5252');
            
            // Add separator before AI category
            const separator = xmlDoc.createElement('sep');
            separator.setAttribute('gap', '36');
            toolbox.appendChild(separator);
            
            toolbox.appendChild(aiCategory);
            return aiCategory;
        }
        
        return null;
    }
    
    /**
     * Process AI suggestion and add generated blocks to palette
     * @param {string} text - Natural language input from user
     */
    function processAISuggestion(text) {
            const blocks = handleAISuggestion(text)
                .map(normalizeToKnownBlock)
                .filter(Boolean)
                .filter(b => isKnownBlockType(b.id));
        let addedCount = 0;
        
        blocks.forEach(block => {
            if (addBlockToPalette(block)) {
                addedCount++;
            }
        });
        
        return {
            success: addedCount > 0,
            blocksAdded: addedCount,
            totalGenerated: blocks.length,
            blocks: blocks
        };
    }
    
    // Return the functions for use by the Blocks component
    return {
        addBlockToPalette,
        processAISuggestion,
        handleAISuggestion
    };
}

/**
 * Example of how to integrate with the Blocks container component
 * This would be called in the componentDidMount method
 */
export function setupAIBlockIntegration(blocksComponent) {
    // Integrate AI block generator
    const aiIntegration = integrateAIBlockGenerator(blocksComponent);
    
    // Add the AI functions to the blocks component instance
    blocksComponent.processAISuggestion = aiIntegration.processAISuggestion;
    blocksComponent.addBlockToPalette = aiIntegration.addBlockToPalette;
    
    // Set up global access for testing/debugging
    if (typeof window !== 'undefined') {
        window.handleAISuggestion = aiIntegration.handleAISuggestion;
        window.processAISuggestion = aiIntegration.processAISuggestion;
    }
    
    console.log('AI Block Generator integration complete');
}

// Example usage:
/*
// In the Blocks container component:

import { setupAIBlockIntegration } from '../lib/ai-block-integration';

class Blocks extends React.Component {
    componentDidMount() {
        // ... existing code ...
        
        // Set up AI block generation
        setupAIBlockIntegration(this);
        
        // ... rest of componentDidMount
    }
    
    // You can now call this.processAISuggestion(text) from anywhere in the component
    // or expose it via props to child components
}

// In an AI sidebar component:
function AISidebar({ onProcessSuggestion }) {
    const [input, setInput] = useState('');
    
    const handleSubmit = () => {
        const result = onProcessSuggestion(input);
        if (result.success) {
            console.log(`Added ${result.blocksAdded} blocks to palette`);
        }
    };
    
    return (
        <div>
            <input 
                value={input} 
                onChange={(e) => setInput(e.target.value)}
                placeholder="Describe the block you want..."
            />
            <button onClick={handleSubmit}>Generate Block</button>
        </div>
    );
}
*/
