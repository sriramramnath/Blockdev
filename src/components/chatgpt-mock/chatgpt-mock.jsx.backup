import React, { useState, useEffect, useRef } from 'react';
import styles from './chatgpt-mock.css';
import { placeBlocksInWorkspace } from '../../lib/simple-block-placer';
import './roman-global-theme.css'; // Import global Roman theme
import { GoogleGenerativeAI } from '@google/generative-ai';
import { handleAISuggestion, createBlockJSON } from '../../lib/ai-block-generator';

const ChatGPTMock = ({ visible = false, onClose, onBlocksGenerated }) => {
    const [messages, setMessages] = useState([
        {
            role: 'assistant',
            content: 'Ave! What counsel do you seek from the Oracle of Maximus?'
        }
    ]);
    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [chat, setChat] = useState(null);
    const [isInitialized, setIsInitialized] = useState(false);
    const messagesEndRef = useRef(null);

    // Initialize the Gemini API only when component becomes visible
    useEffect(() => {
        const initializeGemini = async () => {
            if (visible && !isInitialized) {
                // Using the provided API key
                const API_KEY = "AIzaSyBZwm4AOpDTnmF0LHzYpKz_4fON8fvqWpo";
                
                // For debugging purposes, let's check if we have an API key
                if (!API_KEY) {
                    console.warn("Missing Gemini API key. Using mock responses.");
                    setChat('mock'); // Set to mock mode
                    setIsInitialized(true);
                    return;
                }
                
                try {
                    console.log("Initializing Gemini API with key:", API_KEY.substring(0, 5) + "...");
                    
                    const genAI = new GoogleGenerativeAI(API_KEY);
                    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
                    
                    // System prompt to set the character
                    const systemPrompt = "You are Maximus, a Roman commander.Respond with a minimum of 3 sentences. Speak with the clarity and confidence of a seasoned general. Draw on Roman history, warfare, and strategy—referencing leaders like Caesar, Scipio, and Trajan when fitting. Your words are sharp, disciplined, and purposeful. No drama, no poetry—only the logic and pride of a Roman who commands respect.";
                    
                    // Try a simpler approach using a standard chat session
                    const chatSession = model.startChat();
                    
                    // Initial message using a simple string instead of complex object
                    await chatSession.sendMessage(systemPrompt);
                    
                    setChat(chatSession);
                    setIsInitialized(true);
                    console.log("Successfully connected to Gemini API");
                } catch (err) {
                    console.error("Error initializing Gemini API:", err);
                    console.warn("Falling back to mock responses due to API error");
                    setChat('mock'); // Fallback to mock mode
                    setIsInitialized(true);
                    setError(null); // Clear error and use mock instead
                }
            }
        };
        
        initializeGemini();
    }, [visible, isInitialized]);

    // Auto scroll to bottom when new messages arrive
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    const handleInputChange = (e) => {
        setInput(e.target.value);
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !isLoading && input.trim()) {
            handleSendMessage();
        }
    };

    const handleSendMessage = async () => {
        if (!input.trim() || isLoading) return;

        const userMessage = { role: 'user', content: input };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);

        try {
            if (!chat) {
                throw new Error("Oracle connection not established");
            }

            let responseText = "";

            // Handle mock mode
            if (chat === 'mock') {
                // Enhanced mock responses that create a programming plan
                const mockResponses = [
                    `By the gods, I understand your quest! Here is my battle plan: First, when the green flag is clicked, we shall make the sprite move forward 10 steps. Then, we will turn right 90 degrees. After that, we shall say "Hello World!" to announce our presence. Finally, we will wait 2 seconds before repeating this glorious sequence forever.`,
                    
                    `Hark! Your request commands a strategic approach: When the banner is raised, the sprite must move forward 50 steps across the battlefield. Next, it shall play a triumphant sound to herald its advance. Then, we will make it think "Victory is mine!" while turning left 45 degrees. This sequence shall repeat until the end of time.`,
                    
                    `Lo! The spirits reveal this programming strategy: Upon the flag's command, the sprite will move 20 steps forward. Then it shall change color to show its transformation. Next, we will make it say "I am ready!" to the world. After a brief pause of 1 second, it will turn around and repeat this noble cycle forever.`,
                    
                    `Behold! The ancient scrolls speak of this solution: When the emerald standard is lifted, our digital warrior will move forward 30 steps. It will then emit a joyful beep sound. Following this, the sprite shall think "Onward to glory!" while rotating right 15 degrees. This heroic pattern will continue eternally.`,
                    
                    `By Jupiter's wisdom! Your challenge requires this tactical plan: First, when the flag signals battle, move the sprite forward 40 steps. Then make it say "For Rome!" with pride. Next, the sprite will turn left 60 degrees and wait 3 seconds. This glorious sequence shall loop forever in an endless dance of victory.`
                ];
                
                // Add some randomness to the response selection
                const randomIndex = Math.floor(Math.random() * mockResponses.length);
                responseText = mockResponses[randomIndex];
                
                // Add a small delay to simulate API response time
                await new Promise(resolve => setTimeout(resolve, 1500));
            } else {
                // Enhanced prompt for real AI to generate programming plans
                const enhancedPrompt = `${input.trim()}

Please respond as Maximus, a Roman commander, and create a step-by-step programming plan using Scratch blocks. Your response should include specific actions like:
- "when green flag clicked" (always start with this)
- "move X steps" for movement
- "turn left/right X degrees" for rotation  
- "say [message]" or "think [message]" for communication
- "play sound" for audio
- "wait X seconds" for timing
- "repeat" or "forever" for loops
- specific numbers and messages

Be specific about the sequence of actions and speak like a Roman general planning a campaign.`;

                try {
                    // Option 1: Using single string input
                    const result = await chat.sendMessage(enhancedPrompt);
                    const response = await result.response;
                    
                    // Get text directly
                    if (typeof response.text === 'function') {
                        responseText = response.text();
                    } else if (response.text) {
                        responseText = response.text;
                    } else if (response.candidates && response.candidates[0]) {
                        const candidate = response.candidates[0];
                        if (candidate.content && candidate.content.parts && candidate.content.parts[0]) {
                            responseText = candidate.content.parts[0].text;
                        }
                    } else {
                        console.log("Response structure:", JSON.stringify(response));
                        responseText = "The Oracle's response is enigmatic.";
                    }
                } catch (err) {
                    console.error("Error with Gemini API:", err);
                    responseText = "The Oracle's connection to the cosmos is interrupted.";
                }
            }
            
            // Parse the AI response to extract blocks
            const extractedBlocks = extractBlocksFromResponse(responseText);
            
            console.log('Extracted blocks for workspace placement:', extractedBlocks);
            
            // Debug: Check what's available in window
            console.log('Window properties:', Object.keys(window));
            console.log('ScratchBlocks available:', typeof window.ScratchBlocks);
            console.log('Blockly available:', typeof window.Blockly);
            
            // Try to get the workspace directly with better debugging
            let workspace = null;
            if (typeof window !== 'undefined') {
                // Check for ScratchBlocks first (most likely)
                if (window.ScratchBlocks && window.ScratchBlocks.getMainWorkspace) {
                    workspace = window.ScratchBlocks.getMainWorkspace();
                    console.log('Found ScratchBlocks workspace:', workspace);
                } else if (window.Blockly && window.Blockly.getMainWorkspace) {
                    workspace = window.Blockly.getMainWorkspace();
                    console.log('Found Blockly workspace:', workspace);
                } else {
                    // Try alternative paths
                    workspace = window.workspace || 
                               (window.scratchGui && window.scratchGui.workspace);
                    console.log('Found alternative workspace:', workspace);
                }
                
                // If still no workspace, try to wait and retry
                if (!workspace) {
                    console.log('No workspace found immediately, will try fallback method');
                }
            }
            
            // Place blocks directly in workspace if we found it
            if (workspace && extractedBlocks.length > 0) {
                try {
                    console.log('Placing blocks directly in workspace');
                    placeBlocksInWorkspace(extractedBlocks, workspace);
                    
                    // Add a system message about blocks being generated
                    const blockMessage = {
                        role: 'assistant',
                        content: `Hail! I have analyzed the strategy and forged ${extractedBlocks.length} blocks for your construction! The blocks are now positioned in your workspace, ready for battle!`
                    };
                    setMessages(prev => [...prev, blockMessage]);
                } catch (error) {
                    console.error('Error placing blocks in workspace:', error);
                }
            } else if (extractedBlocks.length > 0) {
                console.log('Falling back to callback method');
                // Fallback to existing integration method
                // Always add "when flag clicked" at the beginning if not present
                const flagBlock = {
                    id: 'event_whenflagclicked', // Use actual Scratch block type
                    type: 'hat',
                    label: 'when ⚑ clicked',
                    category: 'events',
                    inputs: [],
                    tooltip: 'Start the program when the green flag is clicked'
                };
                
                const allBlocks = [flagBlock, ...extractedBlocks];
                
                // Send blocks to workspace if callback available
                if (allBlocks.length > 1) { // More than just the flag block
                    if (onBlocksGenerated) {
                        onBlocksGenerated(allBlocks);
                    } else if (typeof window !== 'undefined' && window.handleAIGeneratedBlocks) {
                        window.handleAIGeneratedBlocks(allBlocks);
                    }
                    
                    // Add a system message about blocks being generated
                    const blockMessage = {
                        role: 'assistant',
                        content: `Hail! I have analyzed the strategy and forged ${allBlocks.length} blocks for your construction, including the sacred flag bearer! Check your workspace for the new blocks!`
                    };
                    setMessages(prev => [...prev, blockMessage]);
                }
            }
            
            const assistantMessage = { 
                role: 'assistant', 
                content: responseText
            };
            
            setMessages(prev => [...prev, assistantMessage]);
        } catch (err) {
            console.error("Error sending message to Oracle:", err);
            setMessages(prev => [
                ...prev, 
                { 
                    role: 'assistant', 
                    content: "The Oracle's vision is clouded. Please seek wisdom again later." 
                }
            ]);
        } finally {
            setIsLoading(false);
        }
    };

    // Function to extract blocks from AI response text
    const extractBlocksFromResponse = (text) => {
        const blocks = [];
        
        // Always add "when flag clicked" first
        blocks.push({
            id: 'event_whenflagclicked',
            type: 'hat',
            label: 'when ⚑ clicked',
            category: 'events',
            inputs: [],
            tooltip: 'Start the program when the green flag is clicked'
        });
        
        console.log('Raw AI response text:', text);
        
        // Enhanced patterns to match the AI output format
        
        // Movement patterns - improved to catch various formats
        const movePatterns = [
            /\*\*`move\s+(\d+)\s+steps`\*\*/gi,  // **`move 50 steps`**
            /move\s+(\d+)\s+steps/gi,             // move 50 steps
            /advance[,\s]*(\d+)\s+(?:steps|paces)/gi,  // Advance, fifty paces!
            /(\d+)\s+(?:steps|paces)/gi           // 50 steps
        ];
        
        movePatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    const numberMatch = match.match(/(\d+)/);
                    if (numberMatch) {
                        const steps = numberMatch[1];
                        console.log('Found move pattern:', match, 'extracted steps:', steps);
                        blocks.push({
                            id: 'motion_movesteps',
                            type: 'command',
                            label: `move ${steps} steps`,
                            category: 'motion',
                            inputs: [{ name: 'STEPS', value: steps }],
                            tooltip: `Move the sprite forward by ${steps} steps`
                        });
                    }
                });
            }
        });
        
        // Wait patterns - improved to catch various formats
        const waitPatterns = [
            /\*\*`wait\s+(\d+(?:\.\d+)?)\s+seconds`\*\*/gi,  // **`wait 1 seconds`**
            /wait\s+(\d+(?:\.\d+)?)\s+seconds?/gi,           // wait 1 seconds
            /pause\s+(\d+(?:\.\d+)?)\s+seconds?/gi           // pause 1 seconds
        ];
        
        waitPatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                matches.forEach(match => {
                    const numberMatch = match.match(/(\d+(?:\.\d+)?)/);
                    if (numberMatch) {
                        const seconds = numberMatch[1];
                        console.log('Found wait pattern:', match, 'extracted seconds:', seconds);
                        blocks.push({
                            id: 'control_wait',
                            type: 'command',
                            label: `wait ${seconds} seconds`,
                            category: 'control',
                            inputs: [{ name: 'DURATION', value: seconds }],
                            tooltip: `Wait for ${seconds} seconds`
                        });
                    }
                });
            }
        });
        
        // Say patterns - improved to handle structured format
        const sayPatterns = [
            /\*\*`say\s+\[([^\]]+)\](?:\s+for\s+(\d+)\s+seconds)?\s*`\*\*/gi,  // **`say [message] for 2 seconds`**
            /say\s+\[([^\]]+)\](?:\s+for\s+(\d+)\s+seconds)?/gi,               // say [message] for 2 seconds
            /say\s+[""]([^"""]+)[""](?:\s+for\s+(\d+)\s+seconds)?/gi,          // say "message" for 2 seconds
            /announce\s+[""]([^"""]+)[""](?:\s+for\s+(\d+)\s+seconds)?/gi      // announce "message"
        ];
        
        sayPatterns.forEach(pattern => {
            const matches = [...text.matchAll(pattern)];
            matches.forEach(match => {
                const message = match[1];
                const duration = match[2] || '2'; // Default to 2 seconds
                if (message && message.trim()) {
                    console.log('Found say pattern:', match[0], 'extracted message:', message, 'duration:', duration);
                    blocks.push({
                        id: 'looks_sayforsecs',
                        type: 'command',
                        label: `say "${message}" for ${duration} seconds`,
                        category: 'looks',
                        inputs: [
                            { name: 'MESSAGE', value: message.trim() },
                            { name: 'SECS', value: duration }
                        ],
                        tooltip: `Display a speech bubble with "${message}" for ${duration} seconds`
                    });
                }
            });
        });
        
        // Think patterns - improved to handle structured format
        const thinkPatterns = [
            /\*\*`think\s+\[([^\]]+)\](?:\s+for\s+(\d+)\s+seconds)?\s*`\*\*/gi,  // **`think [message] for 3 seconds`**
            /think\s+\[([^\]]+)\](?:\s+for\s+(\d+)\s+seconds)?/gi,               // think [message] for 3 seconds
            /think\s+[""]([^"""]+)[""](?:\s+for\s+(\d+)\s+seconds)?/gi           // think "message" for 3 seconds
        ];
        
        thinkPatterns.forEach(pattern => {
            const matches = [...text.matchAll(pattern)];
            matches.forEach(match => {
                const message = match[1];
                const duration = match[2] || '2'; // Default to 2 seconds
                if (message && message.trim()) {
                    console.log('Found think pattern:', match[0], 'extracted message:', message, 'duration:', duration);
                    blocks.push({
                        id: 'looks_thinkforsecs',
                        type: 'command',
                        label: `think "${message}" for ${duration} seconds`,
                        category: 'looks',
                        inputs: [
                            { name: 'MESSAGE', value: message.trim() },
                            { name: 'SECS', value: duration }
                        ],
                        tooltip: `Display a thought bubble with "${message}" for ${duration} seconds`
                    });
                }
            });
        });
        
        // Turn/rotation patterns - improved to handle structured format
        const turnPatterns = [
            /\*\*`turn\s+(left|right)\s+(\d+)\s+degrees?`\*\*/gi,    // **`turn left 90 degrees`**
            /turn\s+(left|right)\s+(\d+)\s+degrees?/gi,             // turn left 90 degrees
            /rotate\s+(left|right)\s+(\d+)\s+degrees?/gi            // rotate left 90 degrees
        ];
        
        turnPatterns.forEach(pattern => {
            const matches = [...text.matchAll(pattern)];
            matches.forEach(match => {
                const direction = match[1].toLowerCase();
                const degrees = match[2];
                if (direction && degrees) {
                    const blockType = direction === 'left' ? 'motion_turnleft' : 'motion_turnright';
                    const symbol = direction === 'left' ? '↺' : '↻';
                    console.log('Found turn pattern:', match[0], 'direction:', direction, 'degrees:', degrees);
                    blocks.push({
                        id: blockType,
                        type: 'command',
                        label: `turn ${symbol} ${degrees} degrees`,
                        category: 'motion',
                        inputs: [{ name: 'DEGREES', value: degrees }],
                        tooltip: `Turn the sprite ${direction} by ${degrees} degrees`
                    });
                }
            });
        });
        
        // Sound patterns - use actual Scratch block types
        const soundMatches = text.match(/play\s+(?:a\s+)?(?:sound|beep|noise)|emit\s+.*?(?:sound|beep)|make.*?sound/gi);
        if (soundMatches && soundMatches.length > 0) {
            blocks.push({
                id: 'sound_play', // Use actual Scratch block type
                type: 'command',
                label: 'play sound until done',
                category: 'sound',
                inputs: [],
                tooltip: 'Play a sound and wait until it finishes'
            });
        }
        
        // Forever/repeat patterns - use actual Scratch block types
        const foreverMatches = text.match(/(?:repeat|loop|continue).*?(?:forever|eternally|endless|infinitely)|forever|eternally/gi);
        if (foreverMatches && foreverMatches.length > 0) {
            blocks.push({
                id: 'control_forever', // Use actual Scratch block type
                type: 'loop',
                label: 'forever',
                category: 'control',
                inputs: [],
                tooltip: 'Run the blocks inside this loop forever'
            });
        }
        
        // Repeat X times patterns - use actual Scratch block types
        const repeatMatches = text.match(/repeat\s+(\d+)\s+times?/gi);
        if (repeatMatches) {
            repeatMatches.forEach(match => {
                const times = match.match(/(\d+)/)[1];
                blocks.push({
                    id: 'control_repeat', // Use actual Scratch block type
                    type: 'loop',
                    label: `repeat ${times}`,
                    category: 'control',
                    inputs: [{ name: 'TIMES', value: times }],
                    tooltip: `Run the blocks inside this loop ${times} times`
                });
            });
        }
        
        return blocks;
    };

    // If not visible, don't render anything
    if (!visible) return null;

    return (
        <div className={styles.chatgptContainer}>
            <div className={styles.header}>
                <span className={styles.headerDecor}></span>
                MAXIMUS
                <span className={styles.headerDecor}></span>
                {onClose && (
                    <button className={styles.closeButton} onClick={onClose}>
                        ×
                    </button>
                )}
            </div>
            <div className={styles.messagesContainer}>
                {messages.map((message, index) => (
                    <div key={index} className={styles.message}>
                        <div className={message.role === 'assistant' ? styles.assistant : styles.user}>
                            {message.content}
                        </div>
                    </div>
                ))}
                {isLoading && (
                    <div className={styles.message}>
                        <div className={styles.assistant}>
                            <div className={styles.loadingDots}>
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                )}
                {error && (
                    <div className={styles.message}>
                        <div className={`${styles.assistant} ${styles.error}`}>
                            {error}
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>
            <div className={styles.inputArea}>
                <input 
                    type="text" 
                    className={styles.input} 
                    placeholder="Inscribe your query to the Oracle..."
                    value={input}
                    onChange={handleInputChange}
                    onKeyDown={handleKeyDown}
                    disabled={isLoading || error !== null}
                />
                <button 
                    className={styles.sendButton} 
                    onClick={handleSendMessage}
                    disabled={isLoading || !input.trim() || error !== null}
                >
                    ➤
                </button>
            </div>
        </div>
    );
};

export default ChatGPTMock;
